#include <iostream>
#include <map>
#include <vector>
#include <atomic>

using namespace std;

/**
 * main - Consider all integer combinations of a^b for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:
 *     2^2=4, 2^3=8, 2^4=16, 2^5=32
 *     3^2=9, 3^3=27, 3^4=81, 3^5=243
 *     4^2=16, 4^3=64, 4^4=256, 4^5=1024
 *     5^2=25, 5^3=125, 5^4=625, 5^5=3125
 *  If they are then placed in numerical order, with any repeats removed, we
 *  get the following sequence of 15 distinct terms:
 *     4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125
 *  How many distinct terms are in the sequence generated by a^b for
 *  2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?
 * Return: 0 if success, 1 if fail
 */
int main()
{
        // The actual value of a^b can be too big for program's integer limit.
        // e.g., 100^100 has 201 digits, ULONG_MAX has 20 digits.
        // Instead, record the prime factorization (pf) of the results.
        // Use a map to store the paired values of the pf array and its hash value (serial number, collision proof).
        // pf array = {pf1, power of pf1, pf2, power of pf2, pf3, power of pf3...}
        // e.g., 18^6 = (2 x 3^2)^6 = 2^6 x 3^12, stored as {2, 6, 3, 12}
        int a, b, min_val = 2, max_val = 100, i, j = 0, factory, tmp;
        map<vector<int>, int> mymap;
        vector<int> pr_factor;

        for (a = min_val; a <= max_val; a++)
        {
                for (b = min_val; b <= max_val; b++)
                {
                        factory = 2, tmp = a, i = 0;
                        while (tmp % factory > 0) // find the 1st prime factor
                                factory++;
                        while (tmp % factory == 0)
                        {
                                i++, tmp /= factory;
                                if (tmp == 1 || (tmp % factory) > 0) // store the factor data
                                        pr_factor.push_back(factory), pr_factor.push_back(i * b), i = 0;
                                if (tmp == 1) // all factors are found
                                {
                                        if (mymap.find(pr_factor) == mymap.end()) // new pf array stored to map
                                                mymap.insert(pair<vector<int>, long>(pr_factor, j)), j++;
                                        pr_factor.clear();
                                        break;
                                }
                                while (tmp % factory > 0) // next factor
                                        factory++;
                        }
                }
        }
	cout << "final ans: " << j << endl, mymap.clear();
        return 0;
}
